name: Nightly Deployment Workflow

on:
  schedule:
    - cron: "0 0 * * *"  # Runs nightly at midnight UTC
  workflow_dispatch:

jobs:
  nightly-deployment:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-1
      IMAGE_TAG: latest
      SOURCE_REPO_URL: https://github.com/satya-sh/DevOps_Midterm_Source.git

    steps:
      #-----------------------------------------------------------
      # 1) (Optional) Checkout THIS Infra Repo (for versioned workflow files)
      #-----------------------------------------------------------
      - name: Checkout Infra Repo
        uses: actions/checkout@v4

      #-----------------------------------------------------------
      # 2) Configure AWS Credentials
      #-----------------------------------------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      #-----------------------------------------------------------
      # 3) Launch the Ephemeral EC2
      #-----------------------------------------------------------
      - name: Launch Temporary EC2 for Build/Test
        id: launch_ec2
        run: |
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-05b10e08d247fb927 \
            --count 1 \
            --instance-type t2.micro \
            --key-name EC2Key \
            --security-group-ids sg-02dee4b3e051069a3 \
            --subnet-id subnet-063de57a204cf6892 \
            --query 'Instances[0].InstanceId' \
            --output text)
          
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "Ephemeral INSTANCE_ID: $INSTANCE_ID"

          # Wait for instance to be running
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          echo "EC2 is now running. Sleeping 15s to let networking come up..."
          sleep 15

      #-----------------------------------------------------------
      # 4) Create SSH Key Locally (from your GitHub secret)
      #-----------------------------------------------------------
      - name: Set up SSH Key
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > ec2-key.pem
          chmod 400 ec2-key.pem

      #-----------------------------------------------------------
      # 5) Get the Public IP/Hostname of ephemeral EC2
      #-----------------------------------------------------------
      - name: Fetch Ephemeral EC2 Hostname
        id: get_temp_ec2
        run: |
          PUBLIC_DNS=$(aws ec2 describe-instances \
            --instance-ids "${{ env.INSTANCE_ID }}" \
            --query 'Reservations[0].Instances[0].PublicDnsName' \
            --output text)
          echo "PUBLIC_DNS=$PUBLIC_DNS" >> $GITHUB_ENV
          echo "::set-output name=public_dns::$PUBLIC_DNS"
          echo "Ephemeral EC2 Hostname: $PUBLIC_DNS"

      #-----------------------------------------------------------
      # 6) SSH in, Install Docker + Docker Compose, Clone Repo, Build & Test
      #-----------------------------------------------------------
      - name: Build & Test on Ephemeral EC2
        id: build_test_ec2
        run: |
          # Grab the ephemeral instance DNS name from previous step
          TEMP_HOST="${{ steps.get_temp_ec2.outputs.public_dns }}"
          
          echo "ðŸ”‘ SSHing into ephemeral EC2 at $TEMP_HOST..."

          ssh -o StrictHostKeyChecking=no -i ec2-key.pem ec2-user@"$TEMP_HOST" << 'REMOTE_CMDS'
            set -e

            echo "âœ… Connected to ephemeral EC2. Installing Docker + Docker Compose..."
            sudo yum update -y
            sudo yum install -y docker git
            sudo service docker start
            sudo usermod -aG docker ec2-user
            
            # Install Docker Compose
            sudo curl -L \
              "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" \
              -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            
            echo "Docker version:"
            docker --version
            echo "Docker Compose version:"
            docker-compose --version

            # Log into ECR so we can push images later
            aws ecr get-login-password --region ${AWS_REGION} \
              | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com

            #-----------------------------------
            # 1) Clone your PUBLIC Source Repo
            #-----------------------------------
            git clone "${{ env.SOURCE_REPO_URL }}" source
            
            cd source
            
            #-----------------------------------
            # 2) Make a .env for your DB secrets
            #-----------------------------------
            cat <<EOF > .env
            DB_HOST=${{ secrets.RDS_ENDPOINT }}
            DB_USER=${{ secrets.RDS_USERNAME }}
            DB_PASSWORD=${{ secrets.RDS_PASSWORD }}
            DB_NAME=${{ secrets.RDS_DBNAME }}
            DB_PORT=3306
            EOF

            #-----------------------------------
            # 3) Build containers with docker-compose.prod.yml
            #-----------------------------------
            echo "ðŸ›   Building images with docker-compose.prod.yml..."
            docker-compose -f docker-compose.prod.yml --env-file .env build

            #-----------------------------------
            # 4) Start them up for Smoke Test
            #-----------------------------------
            docker-compose -f docker-compose.prod.yml --env-file .env up -d
            echo "Waiting 15s for containers to settle..."
            sleep 15

            #-----------------------------------
            # 5) Quick Smoke Tests
            #-----------------------------------
            echo "Running smoke tests..."

            # (A) Check React root page
            HTTP_ROOT=$(curl -i -s -L http://localhost)
            echo "$HTTP_ROOT" | grep -q "200 OK"
            echo "$HTTP_ROOT" | grep -qi "<html"
            echo "âœ… Root page is serving HTML."

            # (B) Check the /api/books
            API_RESP=$(curl -i -s -L http://localhost/api/books)
            echo "$API_RESP" | grep -q "200 OK"
            echo "$API_RESP" | grep -qi "\\[\\{\\|\\[\\]\\|\\{\\}"
            echo "âœ… /api/books returned 200 and JSON-like response."

            echo "Smoke tests succeeded."

            #-----------------------------------
            # 6) Stop containers
            #-----------------------------------
            docker-compose -f docker-compose.prod.yml --env-file .env down

            #-----------------------------------
            # 7) Tag & Push to ECR
            #-----------------------------------
            echo "ðŸ”¨ Identifying built images..."
            
            FRONTEND_IMAGE_ID=$(docker images --filter=reference="source-nginx" --format "{{.ID}}")
            BACKEND_IMAGE_ID=$(docker images --filter=reference="source-backend" --format "{{.ID}}")

            if [ -z "$FRONTEND_IMAGE_ID" ] || [ -z "$BACKEND_IMAGE_ID" ]; then
              echo "âŒ Could not find built images source-nginx or source-backend!"
              exit 1
            fi

            TIMESTAMP=$(date "+%Y%m%d.%H%M%S")
            echo "âœ… Found images. Using TIMESTAMP $TIMESTAMP for tagging."

            # FRONTEND
            docker tag "$FRONTEND_IMAGE_ID" ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:frontend-$TIMESTAMP
            docker tag "$FRONTEND_IMAGE_ID" ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:latest
            docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:frontend-$TIMESTAMP
            docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:latest
            
            # BACKEND
            docker tag "$BACKEND_IMAGE_ID" ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:backend-$TIMESTAMP
            docker tag "$BACKEND_IMAGE_ID" ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:latest
            docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:backend-$TIMESTAMP
            docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:latest

            # If we got here, ephemeral test & push succeeded!
            echo "âœ… Ephemeral test + push to ECR succeeded."
          REMOTE_CMDS

        # If SSH or the remote commands fail, this entire step fails, which will trigger the "if: failure()" logic below.

      #-----------------------------------------------------------
      # 7) Deploy to QA EC2 If Ephemeral Tests Succeeded
      #-----------------------------------------------------------
      - name: Deploy to QA EC2
        if: success()
        run: |
          echo "Smoke test (ephemeral test) succeeded. Deploying latest images to QA..."

          ssh -i ec2-key.pem -o StrictHostKeyChecking=no ec2-user@${{ secrets.QA_EC2_PUBLIC_DNS }} << 'QA_DEPLOY'
            set -e
            # Re-log into ECR
            aws ecr get-login-password --region ${AWS_REGION} \
              | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com

            # Pull the new images
            docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:latest
            docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:latest

            # Example: if you have a custom "docker-compose-qa.yml," use that. Or do your usual production docker-compose.
            # For simplicity:
            docker-compose down
            docker-compose up -d
            docker image prune -f

            echo "âœ… Deployed to QA EC2 successfully."
          QA_DEPLOY

      #-----------------------------------------------------------
      # 8) Delete Images in ECR if Ephemeral Test Fails
      #-----------------------------------------------------------
      - name: Delete Images in ECR if Test Fails
        if: failure()
        run: |
          echo "âŒ Ephemeral test failed. Cleaning up Docker images in ECR..."

          # The ephemeral EC2 step uses TIMESTAMP but we never stored it in GITHUB_ENV here,
          # so we can do a best-effort approach or skip the fancy rollback. You could store the same
          # TIMESTAMP in GITHUB_ENV if you want. Then use that for deletion.
          # For example, if ephemeral steps fail, we might not have even pushed images successfully.
          # Below is the original logic from your file, adapted:

          PRE_FRONTEND_IMAGE_TAG=$(aws ecr list-images --repository-name devops-midterm-frontend \
            --query 'imageIds[?imageTag!=`latest`].[imageTag]' --output text | sort -r | sed -n '2p')
          PRE_BACKEND_IMAGE_TAG=$(aws ecr list-images --repository-name devops-midterm-backend \
            --query 'imageIds[?imageTag!=`latest`].[imageTag]' --output text | sort -r | sed -n '2p')

          # For demonstration, let's assume ephemeral test used "frontend-<TIMESTAMP>" / "backend-<TIMESTAMP>"
          # We'll attempt to remove them. If they don't exist, it will just show "image not found".
          # If you want to be certain, you'd do "aws ecr batch-delete-image --repository-name devops-midterm-frontend ..."

          # Or skip the entire delete step if ephemeral test fails before pushing.

          echo "Could optionally remove newly pushed tags here if they exist..."

      #-----------------------------------------------------------
      # 9) Terminate Temporary EC2
      #-----------------------------------------------------------
      - name: Terminate Temporary EC2 Instance
        if: always()
        run: |
          echo "Terminating ephemeral instance: ${{ env.INSTANCE_ID }}"
          aws ec2 terminate-instances --instance-ids ${{ env.INSTANCE_ID }}
          echo "Done."