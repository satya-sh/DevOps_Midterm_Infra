name: Nightly Deployment Workflow

on:
  schedule:
    - cron: "0 0 * * *"  # Runs nightly at midnight UTC
  workflow_dispatch:

jobs:
  nightly-deployment:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-1
      IMAGE_TAG: latest
      SOURCE_REPO_URL: https://github.com/satya-sh/DevOps_Midterm_Source.git

    steps:
      #-----------------------------------------------------------
      # 1) (Optional) Checkout THIS Infra Repo (for versioned workflow files)
      #-----------------------------------------------------------
      - name: Checkout Infra Repo
        uses: actions/checkout@v4

      #-----------------------------------------------------------
      # 2) Configure AWS Credentials
      #-----------------------------------------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      #-----------------------------------------------------------
      # 3) Launch the Ephemeral EC2
      #-----------------------------------------------------------
      - name: Launch Temporary EC2 for Build/Test
        id: launch_ec2
        run: |
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-05b10e08d247fb927 \
            --count 1 \
            --instance-type t2.micro \
            --key-name EC2Key \
            --security-group-ids sg-02dee4b3e051069a3 \
            --subnet-id subnet-063de57a204cf6892 \
            --query 'Instances[0].InstanceId' \
            --output text)
          
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "Ephemeral INSTANCE_ID: $INSTANCE_ID"

          # Wait for instance to be running
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          echo "EC2 is now running. Sleeping 15s to let networking come up..."
          sleep 15

      #-----------------------------------------------------------
      # 4) Create SSH Key Locally (from your GitHub secret)
      #-----------------------------------------------------------
      - name: Set up SSH Key
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > ec2-key.pem
          chmod 400 ec2-key.pem

      #-----------------------------------------------------------
      # 5) Get the Public IP/Hostname of ephemeral EC2
      #-----------------------------------------------------------
      - name: Fetch Ephemeral EC2 Hostname
        id: get_temp_ec2
        run: |
          PUBLIC_DNS=$(aws ec2 describe-instances \
            --instance-ids "${{ env.INSTANCE_ID }}" \
            --query 'Reservations[0].Instances[0].PublicDnsName' \
            --output text)
          echo "PUBLIC_DNS=$PUBLIC_DNS" >> $GITHUB_ENV
          echo "::set-output name=public_dns::$PUBLIC_DNS"
          echo "Ephemeral EC2 Hostname: $PUBLIC_DNS"

      #-----------------------------------------------------------
      # 6) SSH in to install Docker and initial setup
      #-----------------------------------------------------------
      - name: Install Docker on Ephemeral EC2
        run: |
          TEMP_HOST="${{ steps.get_temp_ec2.outputs.public_dns }}"
          echo "🔑 SSHing into ephemeral EC2 at $TEMP_HOST to install Docker..."

          ssh -o StrictHostKeyChecking=no -i ec2-key.pem ec2-user@"$TEMP_HOST" << 'EOF'
            set -e
            echo "✅ Connected to ephemeral EC2. Installing Docker + Docker Compose..."
            sudo yum update -y
            sudo yum install -y docker git
            sudo service docker start
            sudo usermod -aG docker ec2-user
            
            # Install Docker Compose
            sudo curl -L \
              "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" \
              -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            
            echo "Docker version:"
            docker --version
            echo "Docker Compose version:"
            docker-compose --version
            
            # Create environment files directory for future use
            mkdir -p ~/env_files
          EOF

      #-----------------------------------------------------------
      # 6b) Create environment file on the EC2 instance
      #-----------------------------------------------------------
      - name: Setup Environment Files
        run: |
          TEMP_HOST="${{ steps.get_temp_ec2.outputs.public_dns }}"
          
          # Create .env file content locally
          cat > .env << EOF
          DB_HOST=${{ secrets.RDS_ENDPOINT }}
          DB_USER=${{ secrets.RDS_USERNAME }}
          DB_PASSWORD=${{ secrets.RDS_PASSWORD }}
          DB_NAME=${{ secrets.RDS_DBNAME }}
          DB_PORT=3306
          EOF
          
          # Create AWS credentials file
          cat > aws_creds.sh << EOF
          export AWS_REGION=${{ env.AWS_REGION }}
          export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          export AWS_SESSION_TOKEN=${{ secrets.AWS_SESSION_TOKEN }}
          export AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
          export SOURCE_REPO_URL=${{ env.SOURCE_REPO_URL }}
          EOF
          
          # Create smoke test script with your specified tests
          cat > smoke_tests.sh << 'EOF'
          #!/bin/bash
          set -e

          # (A) Check the root URL:
          echo "Checking React frontend at root URL..."
          HTTP_ROOT=$(curl -i -s -L -k http://localhost/)
          echo "$HTTP_ROOT" | grep -q "200 OK"
          echo "$HTTP_ROOT" | grep -qi "<html"
          echo "✅ Root URL returned 200 and HTML"

          # (B) Check the /api/books endpoint:
          echo "Checking backend API: GET /api/books..."
          HTTP_API=$(curl -i -s -L -k http://localhost/api/books)
          echo "$HTTP_API" | grep -q "200 OK"
          JSON_BODY=$(echo "$HTTP_API" | awk '/^\[|^\{/{flag=1} flag{print}')
          if [[ "$JSON_BODY" =~ ^(\[|\{) ]]; then
            echo "✅ /api/books endpoint returned 200 and valid JSON"
          else
            echo "❌ /api/books returned 200 but did not contain JSON"
            exit 1
          fi

          # (C) A failing test (commented out)
          # echo "Simulating a failing test..."
          # curl -f http://localhost/this-route-doesnt-exist  # Will fail with exit code 22
          # echo "❌ Should never get here, because above line fails."

          echo "All smoke tests passed successfully!"
          EOF
          
          # Copy files to EC2 instance
          scp -o StrictHostKeyChecking=no -i ec2-key.pem .env ec2-user@"$TEMP_HOST":~/env_files/
          scp -o StrictHostKeyChecking=no -i ec2-key.pem aws_creds.sh ec2-user@"$TEMP_HOST":~/env_files/
          scp -o StrictHostKeyChecking=no -i ec2-key.pem smoke_tests.sh ec2-user@"$TEMP_HOST":~/env_files/
          
          # Make smoke test script executable
          ssh -o StrictHostKeyChecking=no -i ec2-key.pem ec2-user@"$TEMP_HOST" "chmod +x ~/env_files/smoke_tests.sh"

      #-----------------------------------------------------------
      # 7) SSH in again to build and test (after group membership is active)
      #-----------------------------------------------------------
      - name: Build & Test on Ephemeral EC2
        id: build_test_ec2
        run: |
          TEMP_HOST="${{ steps.get_temp_ec2.outputs.public_dns }}"
          echo "🔑 SSHing into ephemeral EC2 at $TEMP_HOST for build and test..."

          ssh -o StrictHostKeyChecking=no -i ec2-key.pem ec2-user@"$TEMP_HOST" << 'EOF'
            set -e
            
            # Source AWS credentials
            source ~/env_files/aws_creds.sh
            
            # Log into ECR
            aws ecr get-login-password --region ${AWS_REGION} \
              | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

            # Clone the source repo
            git clone ${SOURCE_REPO_URL} source
            cd source
            
            # Copy the .env file
            cp ~/env_files/.env .
            
            # Build containers with docker-compose
            echo "🛠 Building images with docker-compose.prod.yml..."
            docker-compose -f docker-compose.prod.yml --env-file .env build
            
            # Start containers for smoke test
            docker-compose -f docker-compose.prod.yml --env-file .env up -d
            echo "Waiting 15s for containers to settle..."
            sleep 15
            
            # Run the smoke tests from the script (your specified tests)
            echo "Running smoke tests..."
            ~/env_files/smoke_tests.sh
            
            # Stop containers
            docker-compose -f docker-compose.prod.yml --env-file .env down
            
            # Tag and push to ECR
            echo "🔨 Identifying built images..."
            
            FRONTEND_IMAGE_ID=$(docker images --filter=reference="source-nginx" --format "{{.ID}}")
            BACKEND_IMAGE_ID=$(docker images --filter=reference="source-backend" --format "{{.ID}}")
            
            if [ -z "$FRONTEND_IMAGE_ID" ] || [ -z "$BACKEND_IMAGE_ID" ]; then
              echo "❌ Could not find built images source-nginx or source-backend!"
              exit 1
            fi
            
            TIMESTAMP=$(date "+%Y%m%d.%H%M%S")
            echo "✅ Found images. Using TIMESTAMP $TIMESTAMP for tagging."
            
            # Tag and push frontend
            docker tag "$FRONTEND_IMAGE_ID" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:frontend-$TIMESTAMP
            docker tag "$FRONTEND_IMAGE_ID" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:latest
            docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:frontend-$TIMESTAMP
            docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:latest
            
            # Tag and push backend
            docker tag "$BACKEND_IMAGE_ID" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:backend-$TIMESTAMP
            docker tag "$BACKEND_IMAGE_ID" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:latest
            docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:backend-$TIMESTAMP
            docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:latest
            
            echo "✅ Ephemeral test + push to ECR succeeded."
          EOF

      #-----------------------------------------------------------
      # 8) Deploy to QA EC2 If Ephemeral Tests Succeeded
      #-----------------------------------------------------------
      - name: Deploy to QA EC2
        if: success()
        run: |
          echo "Smoke test (ephemeral test) succeeded. Deploying latest images to QA..."

          ssh -o StrictHostKeyChecking=no -i ec2-key.pem ec2-user@${{ secrets.QA_EC2_PUBLIC_DNS }} << EOF
            export AWS_REGION=${{ env.AWS_REGION }}
            export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            export AWS_SESSION_TOKEN=${{ secrets.AWS_SESSION_TOKEN }}
            export AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
            
            # Re-log into ECR
            aws ecr get-login-password --region \${AWS_REGION} \
              | docker login --username AWS --password-stdin \${AWS_ACCOUNT_ID}.dkr.ecr.\${AWS_REGION}.amazonaws.com
            
            # Pull the new images
            docker pull \${AWS_ACCOUNT_ID}.dkr.ecr.\${AWS_REGION}.amazonaws.com/devops-midterm-frontend:latest
            docker pull \${AWS_ACCOUNT_ID}.dkr.ecr.\${AWS_REGION}.amazonaws.com/devops-midterm-backend:latest
            
            # Deploy with docker-compose
            docker-compose down
            docker-compose up -d
            docker image prune -f
            
            echo "✅ Deployed to QA EC2 successfully."
          EOF

      #-----------------------------------------------------------
      # 9) Delete Images in ECR if Ephemeral Test Fails
      #-----------------------------------------------------------
      - name: Delete Images in ECR if Test Fails
        if: failure()
        run: |
          echo "❌ Ephemeral test failed. Cleaning up Docker images in ECR..."

          # Best-effort approach for cleanup
          PRE_FRONTEND_IMAGE_TAG=$(aws ecr list-images --repository-name devops-midterm-frontend \
            --query 'imageIds[?imageTag!=`latest`].[imageTag]' --output text | sort -r | sed -n '2p')
          PRE_BACKEND_IMAGE_TAG=$(aws ecr list-images --repository-name devops-midterm-backend \
            --query 'imageIds[?imageTag!=`latest`].[imageTag]' --output text | sort -r | sed -n '2p')

          echo "Could optionally remove newly pushed tags here if they exist..."

      #-----------------------------------------------------------
      # 10) Terminate Temporary EC2
      #-----------------------------------------------------------
      - name: Terminate Temporary EC2 Instance
        if: always()
        run: |
          echo "Terminating ephemeral instance: ${{ env.INSTANCE_ID }}"
          aws ec2 terminate-instances --instance-ids ${{ env.INSTANCE_ID }}
          echo "Done."