name: Nightly Deployment Workflow

on:
  schedule:
    - cron: "0 0 * * *"  # Runs nightly at midnight UTC
  workflow_dispatch:

jobs:
  nightly-deployment:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-1
      IMAGE_TAG: latest
      SOURCE_REPO_URL: https://github.com/satya-sh/DevOps_Midterm_Source.git

    steps:
      #-----------------------------------------------------------
      # 1) (Optional) Checkout THIS Infra Repo (for versioned workflow files)
      #-----------------------------------------------------------
      - name: Checkout Infra Repo
        uses: actions/checkout@v4

      #-----------------------------------------------------------
      # 2) Configure AWS Credentials
      #-----------------------------------------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      #-----------------------------------------------------------
      # 3) Launch the Ephemeral EC2
      #-----------------------------------------------------------
      - name: Launch Temporary EC2 for Build/Test
        id: launch_ec2
        run: |
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-05b10e08d247fb927 \
            --count 1 \
            --instance-type t2.micro \
            --key-name EC2Key \
            --security-group-ids sg-02dee4b3e051069a3 \
            --subnet-id subnet-063de57a204cf6892 \
            --query 'Instances[0].InstanceId' \
            --output text)
          
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          echo "Ephemeral INSTANCE_ID: $INSTANCE_ID"

          # Wait for instance to be running
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          echo "EC2 is now running. Sleeping 15s to let networking come up..."
          sleep 15

      #-----------------------------------------------------------
      # 4) Create SSH Key Locally (from your GitHub secret)
      #-----------------------------------------------------------
      - name: Set up SSH Key
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > ec2-key.pem
          chmod 400 ec2-key.pem

      #-----------------------------------------------------------
      # 5) Get the Public IP/Hostname of ephemeral EC2
      #-----------------------------------------------------------
      - name: Fetch Ephemeral EC2 Hostname
        id: get_temp_ec2
        run: |
          PUBLIC_DNS=$(aws ec2 describe-instances \
            --instance-ids "${{ env.INSTANCE_ID }}" \
            --query 'Reservations[0].Instances[0].PublicDnsName' \
            --output text)
          echo "PUBLIC_DNS=$PUBLIC_DNS" >> $GITHUB_ENV
          echo "::set-output name=public_dns::$PUBLIC_DNS"
          echo "Ephemeral EC2 Hostname: $PUBLIC_DNS"

      #-----------------------------------------------------------
      # 6) SSH in, Install Docker + Docker Compose, Clone Repo, Build & Test
      #-----------------------------------------------------------
      - name: Build & Test on Ephemeral EC2
        id: build_test_ec2
        run: |
          # Grab the ephemeral instance DNS name from previous step
          TEMP_HOST="${{ steps.get_temp_ec2.outputs.public_dns }}"
          
          echo "ðŸ”‘ SSHing into ephemeral EC2 at $TEMP_HOST..."

          # First, create a script file with the commands
          cat > ec2_build_script.sh << 'EOF'
          #!/bin/bash
          set -e

          # These variables will be replaced when sending the file
          AWS_REGION="__AWS_REGION__"
          AWS_ACCESS_KEY_ID="__AWS_ACCESS_KEY_ID__"
          AWS_SECRET_ACCESS_KEY="__AWS_SECRET_ACCESS_KEY__"
          AWS_SESSION_TOKEN="__AWS_SESSION_TOKEN__"
          AWS_ACCOUNT_ID="__AWS_ACCOUNT_ID__"
          SOURCE_REPO_URL="__SOURCE_REPO_URL__"
          RDS_ENDPOINT="__RDS_ENDPOINT__"
          RDS_USERNAME="__RDS_USERNAME__"
          RDS_PASSWORD="__RDS_PASSWORD__"
          RDS_DBNAME="__RDS_DBNAME__"

          # Export AWS credentials
          export AWS_REGION
          export AWS_ACCESS_KEY_ID
          export AWS_SECRET_ACCESS_KEY
          export AWS_SESSION_TOKEN

          echo "âœ… Connected to ephemeral EC2. Installing Docker + Docker Compose..."
          sudo yum update -y
          sudo yum install -y docker git
          sudo service docker start
          sudo usermod -aG docker ec2-user

          # Install Docker Compose
          sudo curl -L \
            "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" \
            -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          
          echo "Docker version:"
          docker --version
          echo "Docker Compose version:"
          docker-compose --version

          # Log into ECR so we can push images later
          aws ecr get-login-password --region ${AWS_REGION} \
            | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

          #-----------------------------------
          # 1) Clone your PUBLIC Source Repo
          #-----------------------------------
          git clone "${SOURCE_REPO_URL}" source
          
          cd source
          
          #-----------------------------------
          # 2) Make a .env for your DB secrets
          #-----------------------------------
          cat <<ENVFILE > .env
          DB_HOST=${RDS_ENDPOINT}
          DB_USER=${RDS_USERNAME}
          DB_PASSWORD=${RDS_PASSWORD}
          DB_NAME=${RDS_DBNAME}
          DB_PORT=3306
          ENVFILE

          #-----------------------------------
          # 3) Build containers with docker-compose.prod.yml
          #-----------------------------------
          echo "ðŸ›   Building images with docker-compose.prod.yml..."
          docker-compose -f docker-compose.prod.yml --env-file .env build

          #-----------------------------------
          # 4) Start them up for Smoke Test
          #-----------------------------------
          docker-compose -f docker-compose.prod.yml --env-file .env up -d
          echo "Waiting 15s for containers to settle..."
          sleep 15

          #-----------------------------------
          # 5) Quick Smoke Tests
          #-----------------------------------
          echo "Running smoke tests..."

          # (A) Check React root page
          HTTP_ROOT=$(curl -i -s -L http://localhost)
          echo "$HTTP_ROOT" | grep -q "200 OK"
          echo "$HTTP_ROOT" | grep -qi "<html"
          echo "âœ… Root page is serving HTML."

          # (B) Check the /api/books
          API_RESP=$(curl -i -s -L http://localhost/api/books)
          echo "$API_RESP" | grep -q "200 OK"
          echo "$API_RESP" | grep -qi "\\[\\{\\|\\[\\]\\|\\{\\}"
          echo "âœ… /api/books returned 200 and JSON-like response."

          echo "Smoke tests succeeded."

          #-----------------------------------
          # 6) Stop containers
          #-----------------------------------
          docker-compose -f docker-compose.prod.yml --env-file .env down

          #-----------------------------------
          # 7) Tag & Push to ECR
          #-----------------------------------
          echo "ðŸ”¨ Identifying built images..."
          
          FRONTEND_IMAGE_ID=$(docker images --filter=reference="source-nginx" --format "{{.ID}}")
          BACKEND_IMAGE_ID=$(docker images --filter=reference="source-backend" --format "{{.ID}}")

          if [ -z "$FRONTEND_IMAGE_ID" ] || [ -z "$BACKEND_IMAGE_ID" ]; then
            echo "âŒ Could not find built images source-nginx or source-backend!"
            exit 1
          fi

          TIMESTAMP=$(date "+%Y%m%d.%H%M%S")
          echo "âœ… Found images. Using TIMESTAMP $TIMESTAMP for tagging."

          # FRONTEND
          docker tag "$FRONTEND_IMAGE_ID" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:frontend-$TIMESTAMP
          docker tag "$FRONTEND_IMAGE_ID" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:latest
          docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:frontend-$TIMESTAMP
          docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:latest
          
          # BACKEND
          docker tag "$BACKEND_IMAGE_ID" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:backend-$TIMESTAMP
          docker tag "$BACKEND_IMAGE_ID" ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:latest
          docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:backend-$TIMESTAMP
          docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:latest

          # If we got here, ephemeral test & push succeeded!
          echo "âœ… Ephemeral test + push to ECR succeeded."
          EOF

          # Replace placeholders with actual values
          sed -i "s|__AWS_REGION__|${{ env.AWS_REGION }}|g" ec2_build_script.sh
          sed -i "s|__AWS_ACCESS_KEY_ID__|${{ secrets.AWS_ACCESS_KEY_ID }}|g" ec2_build_script.sh
          sed -i "s|__AWS_SECRET_ACCESS_KEY__|${{ secrets.AWS_SECRET_ACCESS_KEY }}|g" ec2_build_script.sh
          sed -i "s|__AWS_SESSION_TOKEN__|${{ secrets.AWS_SESSION_TOKEN }}|g" ec2_build_script.sh
          sed -i "s|__AWS_ACCOUNT_ID__|${{ secrets.AWS_ACCOUNT_ID }}|g" ec2_build_script.sh
          sed -i "s|__SOURCE_REPO_URL__|${{ env.SOURCE_REPO_URL }}|g" ec2_build_script.sh
          sed -i "s|__RDS_ENDPOINT__|${{ secrets.RDS_ENDPOINT }}|g" ec2_build_script.sh
          sed -i "s|__RDS_USERNAME__|${{ secrets.RDS_USERNAME }}|g" ec2_build_script.sh
          sed -i "s|__RDS_PASSWORD__|${{ secrets.RDS_PASSWORD }}|g" ec2_build_script.sh
          sed -i "s|__RDS_DBNAME__|${{ secrets.RDS_DBNAME }}|g" ec2_build_script.sh

          # Copy the script to the EC2 instance
          scp -o StrictHostKeyChecking=no -i ec2-key.pem ec2_build_script.sh ec2-user@"$TEMP_HOST":/home/ec2-user/ec2_build_script.sh
          
          # Run the script on the EC2 instance
          ssh -o StrictHostKeyChecking=no -i ec2-key.pem ec2-user@"$TEMP_HOST" "chmod +x /home/ec2-user/ec2_build_script.sh && /home/ec2-user/ec2_build_script.sh"

        # If SSH or the remote commands fail, this entire step fails, which will trigger the "if: failure()" logic below.

      #-----------------------------------------------------------
      # 7) Deploy to QA EC2 If Ephemeral Tests Succeeded
      #-----------------------------------------------------------
      - name: Deploy to QA EC2
        if: success()
        run: |
          echo "Smoke test (ephemeral test) succeeded. Deploying latest images to QA..."
          
          # Create QA deployment script
          cat > qa_deploy_script.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # These variables will be replaced
          AWS_REGION="__AWS_REGION__"
          AWS_ACCESS_KEY_ID="__AWS_ACCESS_KEY_ID__"
          AWS_SECRET_ACCESS_KEY="__AWS_SECRET_ACCESS_KEY__"
          AWS_SESSION_TOKEN="__AWS_SESSION_TOKEN__"
          AWS_ACCOUNT_ID="__AWS_ACCOUNT_ID__"
          
          # Export AWS credentials
          export AWS_REGION
          export AWS_ACCESS_KEY_ID
          export AWS_SECRET_ACCESS_KEY
          export AWS_SESSION_TOKEN
          
          # Re-log into ECR
          aws ecr get-login-password --region ${AWS_REGION} \
            | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

          # Pull the new images
          docker pull ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-frontend:latest
          docker pull ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/devops-midterm-backend:latest

          # Example: if you have a custom "docker-compose-qa.yml," use that. Or do your usual production docker-compose.
          # For simplicity:
          docker-compose down
          docker-compose up -d
          docker image prune -f

          echo "âœ… Deployed to QA EC2 successfully."
          EOF
          
          # Replace placeholders with actual values
          sed -i "s|__AWS_REGION__|${{ env.AWS_REGION }}|g" qa_deploy_script.sh
          sed -i "s|__AWS_ACCESS_KEY_ID__|${{ secrets.AWS_ACCESS_KEY_ID }}|g" qa_deploy_script.sh
          sed -i "s|__AWS_SECRET_ACCESS_KEY__|${{ secrets.AWS_SECRET_ACCESS_KEY }}|g" qa_deploy_script.sh
          sed -i "s|__AWS_SESSION_TOKEN__|${{ secrets.AWS_SESSION_TOKEN }}|g" qa_deploy_script.sh
          sed -i "s|__AWS_ACCOUNT_ID__|${{ secrets.AWS_ACCOUNT_ID }}|g" qa_deploy_script.sh
          
          # Copy the script to the EC2 instance
          scp -o StrictHostKeyChecking=no -i ec2-key.pem qa_deploy_script.sh ec2-user@${{ secrets.QA_EC2_PUBLIC_DNS }}:/home/ec2-user/qa_deploy_script.sh
          
          # Run the script on the EC2 instance
          ssh -o StrictHostKeyChecking=no -i ec2-key.pem ec2-user@${{ secrets.QA_EC2_PUBLIC_DNS }} "chmod +x /home/ec2-user/qa_deploy_script.sh && /home/ec2-user/qa_deploy_script.sh"

      #-----------------------------------------------------------
      # 8) Delete Images in ECR if Ephemeral Test Fails
      #-----------------------------------------------------------
      - name: Delete Images in ECR if Test Fails
        if: failure()
        run: |
          echo "âŒ Ephemeral test failed. Cleaning up Docker images in ECR..."

          # The ephemeral EC2 step uses TIMESTAMP but we never stored it in GITHUB_ENV here,
          # so we can do a best-effort approach or skip the fancy rollback. You could store the same
          # TIMESTAMP in GITHUB_ENV if you want. Then use that for deletion.
          # For example, if ephemeral steps fail, we might not have even pushed images successfully.
          # Below is the original logic from your file, adapted:

          PRE_FRONTEND_IMAGE_TAG=$(aws ecr list-images --repository-name devops-midterm-frontend \
            --query 'imageIds[?imageTag!=`latest`].[imageTag]' --output text | sort -r | sed -n '2p')
          PRE_BACKEND_IMAGE_TAG=$(aws ecr list-images --repository-name devops-midterm-backend \
            --query 'imageIds[?imageTag!=`latest`].[imageTag]' --output text | sort -r | sed -n '2p')

          # For demonstration, let's assume ephemeral test used "frontend-<TIMESTAMP>" / "backend-<TIMESTAMP>"
          # We'll attempt to remove them. If they don't exist, it will just show "image not found".
          # If you want to be certain, you'd do "aws ecr batch-delete-image --repository-name devops-midterm-frontend ..."

          # Or skip the entire delete step if ephemeral test fails before pushing.

          echo "Could optionally remove newly pushed tags here if they exist..."

      #-----------------------------------------------------------
      # 9) Terminate Temporary EC2
      #-----------------------------------------------------------
      - name: Terminate Temporary EC2 Instance
        if: always()
        run: |
          echo "Terminating ephemeral instance: ${{ env.INSTANCE_ID }}"
          aws ec2 terminate-instances --instance-ids ${{ env.INSTANCE_ID }}
          echo "Done."